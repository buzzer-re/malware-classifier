#!/usr/bin/python3

import pefile
import hashlib
import ssdeep
import argparse
import sys
import os

class Extractor:
    def __init__(self, pe_path = None):
        self.pe_path = pe_path
        self.pe = None
        if pe_path != None:
            self.__load_pe()

    def load_pe(self, pe_path):
        self.pe_path = pe_path
        self.__load_pe()
    

    def __load_pe(self):
        try:
            self.pe =pefile.PE(self.pe_path)
        except Exception as e :
            print("Error on parse PE {}".format(pe_path))

    def get_imphash(self):
        return self.pe.get_imphash()
    
    def get_impfuzzy(self):
        '''
        Extract ImpFuzzy by taking all the imports strings separeted by a commoan and hashing with a fuzzy hash, ssdeep or tlsh

        '''
        if not hasattr(self.pe, 'DIRECTORY_ENTRY_IMPORT'):
            return None

        imports = ''
        for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode().lower().split('.')[0] # remove .dll
            
            for imp in entry.imports:
                import_name = imp.name
                if import_name is None:
                    import_name = pefile.ordlookup.ordLookup(entry.dll.lower(), imp.ordinal, make_name=True)
                    if import_name is None:
                        return None

                    
                import_name = import_name.decode().lower()
                imports += '{}.{},'.format(dll_name, import_name)

        imports = imports[:-1] # remove the last ','


        return ssdeep.hash(imports)
    

    def check_packed(self, use_yara):
        # if use_yara:
        #     self.__compile_rules()
        #     if self.__yara_check_packers(self.pe):
        #         return True
            
        # # Native library
        # sections_entropy = peutils.calc_entropy()

        # for entropy in sections:
        #     if entropy >= 7.7:
        #         return True
            
        return False


if __name__ == '__main__':
    args = argparse.ArgumentParser(description="PE feature extractor")
    args.add_argument("pe_folder", help="Path to the folder where is the PE files", type=str)
    args.add_argument("--output", "-o", help="Output where the dataset should be saved", type=str)
    args.add_argument("--format", "-f", help="Format that the dataset should be exported, default = csv", default="csv", type=str)
    args = args.parse_args()

    
    pe_path = args.pe_folder
    
    feature_extractor = Extractor()
    features = []

    for root, dirs, files in os.walk(pe_path):
        for f in files:
            full_path = os.path.join(root, f)
            is_pe = False 
            with open(full_path, "rb") as fd:
                is_pe = fd.read(2) == b'MZ'
            
            if is_pe:
                print("Sample: {}".format(f))
                feature_extractor.load_pe(full_path)
                features_dict = {
                    'imphash': feature_extractor.get_imphash(),
                    'impfuzzy': feature_extractor.get_impfuzzy(),
                    'is_packed': feature_extractor.check_packed(use_yara=True)
                    # 'suspicious_timestamp': feature_extractor.check_timestamp(),
                    # 'has_padding': feature_extractor.has_padding(),
                    # 'strings':  feature_extractor.extract_strings(pattern=feature_extractor.C2_PATTERNS)
                    # 'ssdeep':   feature_extractor.extract_ssdeep(),
                    # 'tlsh': feature_extractor.has_padding(),
                    # 'sha256': feature_extractor.get_sha256()
                }
                
                features.append(features_dict)

                for feature_name, value in features_dict.items():
                    print("{} - {}".format(feature_name, value))
                
                print("\n")

                


        
